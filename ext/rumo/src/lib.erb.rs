require 'erb'
TYPES = [
    ["UInt8", "u8"],
    ["Int8", "i8"],
    ["UInt16", "u16"],
    ["Int16", "i16"],
    ["UInt32", "u32"],
    ["Int32", "i32"],
    ["UInt64", "u64"],
    ["Int64", "i64"],
    ["Float32", "f32"],
    ["Float64", "f64"],
]
code = ERB.new(DATA.read, trim_mode: "<>").result(binding)
Dir.chdir(__dir__) { File.write("lib.rs", code) }
__END__
// This file is generated by ERB. Do not edit.

extern crate magnus;
extern crate ndarray;
use ndarray::{array, prelude::*, Array, ArrayD, ArrayView, IxDyn};

use magnus::{define_class, define_module, eval, function, method, prelude::*, Error};

trait NArray {
    fn zeros(dims: Vec<usize>) -> Self;
    fn ones(dims: Vec<usize>) -> Self;
    fn shape(&self) -> Vec<usize>;
    fn ndim(&self) -> usize;
    fn length(&self) -> usize;
    fn inspect(&self) -> String;
}

<% TYPES.each do |type, rust_type| %>

#[magnus::wrap(class = "Rumo::<%= type %>")]
struct <%= type %> {
    nda: ArrayD<<%= rust_type %>>,
}

impl NArray for <%= type %> {
    fn zeros(dims: Vec<usize>) -> Self {
        let mut nda = ArrayD::<<%= rust_type %>>::zeros(IxDyn(&dims));
        Self { nda }
    }
    fn ones(dims: Vec<usize>) -> Self {
        let mut nda = ArrayD::<<%= rust_type %>>::ones(IxDyn(&dims));
        Self { nda }
    }
    fn shape(&self) -> Vec<usize> {
        self.nda.shape().to_vec()
    }
    fn ndim(&self) -> usize {
        self.nda.ndim()
    }
    fn length(&self) -> usize {
        self.nda.len()
    }
    fn inspect(&self) -> String {
        self.nda.to_string()
    }
}

impl <%= type %> {
    fn sum(&self) -> <%= rust_type %> {
        self.nda.sum()
    }
    fn product(&self) -> <%= rust_type %> {
        self.nda.product()
    }
}
<% end %>

#[magnus::init]
fn init() -> Result<(), Error> {
    let module = define_module("Rumo")?;

<% TYPES.each do |type, rust_type| %>
    let class_<%= rust_type %> = module.define_class("<%= type %>", Default::default())?;
    class_<%= rust_type %>.define_singleton_method("_zeros", function!(<%= type %>::zeros, 1))?;
    class_<%= rust_type %>.define_singleton_method("_ones", function!(<%= type %>::ones, 1))?;
    class_<%= rust_type %>.define_method("shape", method!(<%= type %>::shape, 0))?;
    class_<%= rust_type %>.define_method("ndim", method!(<%= type %>::ndim, 0))?;
    class_<%= rust_type %>.define_method("length", method!(<%= type %>::length, 0))?;
    class_<%= rust_type %>.define_method("size", method!(<%= type %>::length, 0))?;
    class_<%= rust_type %>.define_method("sum", method!(<%= type %>::sum, 0))?;
    class_<%= rust_type %>.define_method("prod", method!(<%= type %>::product, 0))?;
    class_<%= rust_type %>.define_method("inspect", method!(<%= type %>::inspect, 0))?;
<% end %>

    eval::<bool>("Rumo::SFloat = Rumo::Float32")?;
    eval::<bool>("Rumo::DFloat = Rumo::Float64")?;

    Ok(())
}
